use crate::report::NttConfigGenerator;
use crate::types::{FullAnalysis, IssueSeverity, MigrationPath, MigrationPlan, RiskRating};

/// Generates markdown reports
pub struct MarkdownGenerator;

impl MarkdownGenerator {
    /// Generate full migration report
    pub fn generate(analysis: &FullAnalysis, plan: &MigrationPlan) -> String {
        let mut md = String::new();

        // Header
        md.push_str(&format!(
            "# Migration Report: {} ({})\n\n",
            analysis.token.name, analysis.token.symbol
        ));
        md.push_str("> Generated by Daybreak - EVM to Solana Migration Tool\n\n");

        // Summary
        md.push_str("## Summary\n\n");
        md.push_str(&format!(
            "| Property | Value |\n\
             |----------|-------|\n\
             | Token | {} ({}) |\n\
             | Chain | {} |\n\
             | Address | `{}` |\n\
             | Decimals | {} |\n\
             | Risk Score | {}/100 ({}) |\n\
             | NTT Compatible | {} |\n\
             | Recommended Path | {} |\n\n",
            analysis.token.name,
            analysis.token.symbol,
            analysis.token.chain,
            analysis.token.address,
            analysis.token.decimals,
            analysis.risk_score.total,
            analysis.risk_score.rating,
            if analysis.compatibility.is_compatible {
                "Yes"
            } else {
                "No"
            },
            plan.recommended_path
        ));

        // Risk Score Details
        md.push_str("## Risk Assessment\n\n");
        md.push_str(&Self::risk_badge(&analysis.risk_score.rating));
        md.push_str("\n\n");
        md.push_str("| Component | Score | Max |\n");
        md.push_str("|-----------|-------|-----|\n");
        md.push_str(&format!(
            "| Decimal Handling | {} | 20 |\n",
            analysis.risk_score.components.decimal_handling
        ));
        md.push_str(&format!(
            "| Token Features | {} | 25 |\n",
            analysis.risk_score.components.token_features
        ));
        md.push_str(&format!(
            "| Bytecode Complexity | {} | 20 |\n",
            analysis.risk_score.components.bytecode_complexity
        ));
        md.push_str(&format!(
            "| Holder Concentration | {} | 15 |\n",
            analysis.risk_score.components.holder_concentration
        ));
        md.push_str(&format!(
            "| Bridge Status | {} | 20 |\n",
            analysis.risk_score.components.bridge_status
        ));
        md.push_str(&format!(
            "| **Total** | **{}** | **100** |\n\n",
            analysis.risk_score.total
        ));

        // Estimated Costs
        md.push_str("## Estimated Costs\n\n");
        md.push_str("| Item | Cost |\n");
        md.push_str("|------|------|\n");
        md.push_str("| SPL Token Mint (rent) | ~0.002 SOL |\n");
        md.push_str("| NTT Manager deployment | ~0.3 SOL |\n");
        md.push_str("| Transceiver setup | ~0.1 SOL |\n");
        md.push_str("| Rate limiter config | ~0.05 SOL |\n");
        md.push_str("| Test transfers (devnet) | Free |\n");
        md.push_str("| **Total estimated** | **~0.5 SOL** |\n\n");
        md.push_str(&format!(
            "*EVM-side: Budget ~0.05 ETH for NTT contract deployment on {}.*\n\n",
            analysis.token.chain
        ));

        // Rate Limit Recommendation
        md.push_str("## Rate Limit Recommendation\n\n");
        match &analysis.rate_limit {
            Some(rl) => {
                md.push_str("| Parameter | Value |\n");
                md.push_str("|-----------|-------|\n");
                md.push_str(&format!(
                    "| Daily inbound limit | {} tokens |\n",
                    rl.recommended_daily_limit
                ));
                md.push_str(&format!(
                    "| Per-transaction limit | {} tokens |\n",
                    rl.recommended_per_tx_limit
                ));
                if rl.daily_transfers > 0 {
                    md.push_str(&format!(
                        "| Observed daily transfers | ~{} |\n",
                        rl.daily_transfers
                    ));
                }
                md.push_str(&format!(
                    "| High volume warning | {} |\n\n",
                    if rl.high_volume_warning { "Yes" } else { "No" }
                ));
                md.push_str(&format!("> {}\n\n", rl.reasoning));
                if rl.high_volume_warning {
                    md.push_str(
                        "> ⚠️ **High-volume token**: Consider setting tighter per-transaction limits \
                         to prevent large single-transfer exploits.\n\n",
                    );
                }
            }
            None => {
                md.push_str(
                    "*Rate limit data unavailable. Run with `--etherscan-key` for volume-based \
                     rate limit recommendations. Using default: 1,000,000 tokens/day.*\n\n",
                );
            }
        }

        // Token Capabilities
        md.push_str("## Token Capabilities\n\n");
        md.push_str("| Feature | Status |\n");
        md.push_str("|---------|--------|\n");
        md.push_str(&format!(
            "| Mintable | {} |\n",
            Self::bool_emoji(analysis.capabilities.has_mint)
        ));
        md.push_str(&format!(
            "| Burnable | {} |\n",
            Self::bool_emoji(analysis.capabilities.has_burn)
        ));
        md.push_str(&format!(
            "| Pausable | {} |\n",
            Self::bool_emoji(analysis.capabilities.has_pause)
        ));
        md.push_str(&format!(
            "| Blacklist | {} |\n",
            Self::bool_emoji(analysis.capabilities.has_blacklist)
        ));
        md.push_str(&format!(
            "| Upgradeable | {} |\n",
            Self::bool_emoji(analysis.capabilities.is_upgradeable)
        ));
        if analysis.capabilities.is_rebasing {
            md.push_str("| **Rebasing** | **Yes ⚠️** |\n");
        }
        md.push('\n');

        // Bytecode Analysis
        md.push_str("## Bytecode Analysis\n\n");
        md.push_str(&format!(
            "- **Size**: {} bytes ({})\n",
            analysis.bytecode.size_bytes, analysis.bytecode.complexity
        ));
        md.push_str(&format!(
            "- **Is Proxy**: {}\n",
            if analysis.bytecode.is_proxy {
                "Yes"
            } else {
                "No"
            }
        ));
        if let Some(ref proxy_type) = analysis.bytecode.proxy_type {
            md.push_str(&format!("- **Proxy Type**: {}\n", proxy_type));
        }
        if let Some(ref impl_addr) = analysis.bytecode.implementation_address {
            md.push_str(&format!("- **Implementation**: `{}`\n", impl_addr));
        }
        if analysis.bytecode.has_selfdestruct {
            md.push_str("- **Warning**: Contains `selfdestruct` opcode\n");
        }
        if analysis.bytecode.has_fee_pattern {
            md.push_str("- **Warning**: Fee-on-transfer pattern detected\n");
        }
        md.push('\n');

        // Holder Distribution
        md.push_str("## Holder Distribution\n\n");
        match &analysis.holder_data {
            Some(data) => {
                md.push_str(&format!(
                    "Top-10 concentration: **{:.1}%**\n\n",
                    data.top_10_concentration
                ));
                if !data.top_holders.is_empty() {
                    md.push_str("| # | Address | Percentage |\n");
                    md.push_str("|---|---------|------------|\n");
                    let show = data.top_holders.len().min(10);
                    for (i, holder) in data.top_holders[..show].iter().enumerate() {
                        let addr = if holder.address.len() > 12 {
                            format!(
                                "`{}...{}`",
                                &holder.address[..6],
                                &holder.address[holder.address.len() - 4..]
                            )
                        } else {
                            format!("`{}`", holder.address)
                        };
                        md.push_str(&format!(
                            "| {} | {} | {:.2}% |\n",
                            i + 1,
                            addr,
                            holder.percentage
                        ));
                    }
                    md.push('\n');

                    if let Some(top) = data.top_holders.first() {
                        if top.percentage > 50.0 {
                            md.push_str(&format!(
                                "> ⚠️ **Concentration Risk**: Top holder controls {:.1}% of supply\n\n",
                                top.percentage
                            ));
                        }
                    }
                }
            }
            None => {
                md.push_str(
                    "*Holder data unavailable. Run with `--etherscan-key` for distribution analysis. \
                     Missing data adds a small penalty to the risk score.*\n\n",
                );
            }
        }

        // Decimal Migration
        if analysis.compatibility.decimal_trimming_required {
            let evm_dec = analysis.token.decimals;
            let sol_dec = analysis.compatibility.solana_decimals;
            let trimmed = evm_dec - sol_dec;
            let kept: String = (0..sol_dec).map(|i| char::from(b'1' + (i % 9))).collect();
            let dust: String = (0..trimmed)
                .map(|i| char::from(b'1' + ((sol_dec + i) % 9)))
                .collect();
            let max_loss = 1.0 / 10f64.powi(sol_dec as i32);

            md.push_str("## Decimal Migration\n\n");
            md.push_str(&format!(
                "NTT caps SPL tokens at 8 decimals. This token uses {} decimals, so amounts are trimmed to {}.\n\n",
                evm_dec, sol_dec
            ));
            md.push_str("**Worked example:**\n\n");
            md.push_str("| | Value |\n");
            md.push_str("|--|-------|\n");
            md.push_str(&format!("| EVM amount | `1.{}{}` |\n", kept, dust));
            md.push_str(&format!("| Solana amount | `1.{}` |\n", kept));
            md.push_str(&format!(
                "| Dust (locked) | `0.{}{}` |\n",
                "0".repeat(sol_dec as usize),
                dust
            ));
            md.push_str(&format!(
                "| Max precision loss | < {} tokens per transfer |\n\n",
                max_loss
            ));
            md.push_str(
                "> Dust is **locked** on the source chain, not destroyed. \
                 It can be recovered if the token is bridged back.\n\n",
            );
        }

        // Compatibility Issues
        if !analysis.compatibility.issues.is_empty() {
            md.push_str("## Compatibility Issues\n\n");
            for issue in &analysis.compatibility.issues {
                let icon = match issue.severity {
                    IssueSeverity::Info => "ℹ️",
                    IssueSeverity::Warning => "⚠️",
                    IssueSeverity::Error => "❌",
                };
                md.push_str(&format!("### {} {}\n\n", icon, issue.title));
                md.push_str(&format!("{}\n\n", issue.description));
                md.push_str(&format!("**Recommendation**: {}\n\n", issue.recommendation));
            }
        }

        // Migration Paths Comparison
        md.push_str("## Migration Paths\n\n");
        md.push_str(&Self::generate_comparison_table(&plan.paths));
        md.push('\n');

        // Detailed path analysis
        for path in &plan.paths {
            md.push_str(&format!("### {}\n\n", path.method));
            md.push_str(&format!("**Feasibility**: {}\n\n", path.feasibility));
            md.push_str(&format!(
                "- **Estimated Cost**: {}\n",
                path.estimated_cost_usd
            ));
            md.push_str(&format!(
                "- **Estimated Time**: {}\n\n",
                path.estimated_time
            ));

            if !path.pros.is_empty() {
                md.push_str("**Pros**:\n");
                for pro in &path.pros {
                    md.push_str(&format!("- {}\n", pro));
                }
                md.push('\n');
            }

            if !path.cons.is_empty() {
                md.push_str("**Cons**:\n");
                for con in &path.cons {
                    md.push_str(&format!("- {}\n", con));
                }
                md.push('\n');
            }
        }

        // Pre-Migration Checklist
        md.push_str("## Pre-Migration Checklist\n\n");
        md.push_str("- [ ] Verify token contract ownership/admin access\n");
        md.push_str("- [ ] Review NTT compatibility issues above\n");
        md.push_str("- [ ] Set up deployment wallets (EVM + Solana)\n");
        md.push_str("- [ ] Install NTT CLI: `npm install -g @wormhole-foundation/ntt-cli`\n");
        md.push_str(&format!(
            "- [ ] Deploy SPL token on devnet: `daybreak deploy {} --chain {}`\n",
            analysis.token.address,
            analysis.token.chain.to_string().to_lowercase()
        ));
        md.push_str("- [ ] Test NTT deployment on devnet first\n");
        md.push_str("- [ ] Configure rate limits based on expected volume\n");
        md.push_str(
            "- [ ] Apply for Sunrise listing at [sunrise.wtf](https://www.sunrise.wtf)\n\n",
        );

        // Migration Steps (for recommended path)
        md.push_str("## Migration Steps\n\n");
        for step in &plan.steps {
            md.push_str(&format!("### Step {}: {}\n\n", step.order, step.title));
            md.push_str(&format!("{}\n\n", step.description));
            if let Some(ref cmd) = step.command {
                md.push_str(&format!("```bash\n{}\n```\n\n", cmd));
            }
        }

        // NTT CLI Commands
        md.push_str("## NTT CLI Commands\n\n");
        md.push_str("```bash\n");
        for cmd in NttConfigGenerator::generate_cli_commands(analysis) {
            md.push_str(&format!("{}\n", cmd));
        }
        md.push_str("```\n\n");

        // Next Steps with Sunrise
        md.push_str("## Next Steps with Sunrise\n\n");
        md.push_str("Sunrise is Solana's canonical asset gateway powered by Wormhole NTT:\n");
        md.push_str("- **Day-one liquidity** — immediate trading on Jupiter\n");
        md.push_str("- **Native tokens** — no wrapped token complexity\n");
        md.push_str("- **Canonical routing** — become the official Solana version\n\n");
        md.push_str("**To get listed:**\n");
        md.push_str("1. Complete the migration steps above\n");
        md.push_str("2. Apply at [sunrise.wtf](https://www.sunrise.wtf)\n");
        md.push_str("3. Expected timeline: 1-2 weeks for review\n\n");
        md.push_str("---\n");
        md.push_str("*Generated by [Daybreak](https://github.com/Jpatching/daybreak) — Migration planning for Solana via Sunrise*\n");

        md
    }

    fn risk_badge(rating: &RiskRating) -> String {
        match rating {
            RiskRating::Low => {
                "![Risk: Low](https://img.shields.io/badge/Risk-Low-green)".to_string()
            }
            RiskRating::Medium => {
                "![Risk: Medium](https://img.shields.io/badge/Risk-Medium-yellow)".to_string()
            }
            RiskRating::High => {
                "![Risk: High](https://img.shields.io/badge/Risk-High-red)".to_string()
            }
        }
    }

    fn bool_emoji(value: bool) -> &'static str {
        if value {
            "Yes"
        } else {
            "No"
        }
    }

    fn generate_comparison_table(paths: &[MigrationPath]) -> String {
        let mut table = String::new();
        table.push_str("| Aspect | NTT (Sunrise) | Neon EVM | Native Rewrite |\n");
        table.push_str("|--------|---------------|----------|----------------|\n");

        // Find each path
        let ntt = paths
            .iter()
            .find(|p| matches!(p.method, crate::types::MigrationMethod::NttSunrise));
        let neon = paths
            .iter()
            .find(|p| matches!(p.method, crate::types::MigrationMethod::NeonEvm));
        let native = paths
            .iter()
            .find(|p| matches!(p.method, crate::types::MigrationMethod::NativeRewrite));

        table.push_str(&format!(
            "| Feasibility | {} | {} | {} |\n",
            ntt.map(|p| p.feasibility.to_string()).unwrap_or_default(),
            neon.map(|p| p.feasibility.to_string()).unwrap_or_default(),
            native
                .map(|p| p.feasibility.to_string())
                .unwrap_or_default(),
        ));

        table.push_str(&format!(
            "| Cost | {} | {} | {} |\n",
            ntt.map(|p| p.estimated_cost_usd.as_str()).unwrap_or("-"),
            neon.map(|p| p.estimated_cost_usd.as_str()).unwrap_or("-"),
            native.map(|p| p.estimated_cost_usd.as_str()).unwrap_or("-"),
        ));

        table.push_str(&format!(
            "| Time | {} | {} | {} |\n",
            ntt.map(|p| p.estimated_time.as_str()).unwrap_or("-"),
            neon.map(|p| p.estimated_time.as_str()).unwrap_or("-"),
            native.map(|p| p.estimated_time.as_str()).unwrap_or("-"),
        ));

        table
    }
}
